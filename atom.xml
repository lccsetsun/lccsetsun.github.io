<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>setsun</title>
  
  <subtitle>For incalculable value</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lccsetsun.github.io/"/>
  <updated>2019-06-07T07:05:06.323Z</updated>
  <id>https://lccsetsun.github.io/</id>
  
  <author>
    <name>setsun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sql优化-简单介绍</title>
    <link href="https://lccsetsun.github.io/2019/05/28/%E6%95%B0%E6%8D%AE%E5%BA%93%20SQL%20%E4%BC%98%E5%8C%96/"/>
    <id>https://lccsetsun.github.io/2019/05/28/数据库 SQL 优化/</id>
    <published>2019-05-28T13:05:38.000Z</published>
    <updated>2019-06-07T07:05:06.323Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/6.jpg" alt="hashmap"></p><a id="more"></a><h1 id="数据库-SQL-优化"><a href="#数据库-SQL-优化" class="headerlink" title="数据库 SQL 优化"></a>数据库 SQL 优化</h1><p>1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 <code>where</code> 及 <code>order by</code> 涉及的列上建立索引。</p><p>2.应尽量避免在 <code>where</code> 子句中对字段进行 <code>null</code> 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><p><code>mysqlselect id from t where num is null</code>mysql</p><p>最好不要给数据库留<code>NULL</code>，尽可能的使用 <code>NOT NULL</code>填充数据库.</p><p>备注、描述、评论之类的可以设置为 <code>NULL</code>，其他的，最好不要使用<code>NULL</code>。</p><p>不要以为 <code>NULL</code> 不需要空间，比如：<code>char(100)</code> 型，在字段建立时，空间就固定了， 不管是否插入值（<code>NULL</code>也包含在内），都是占用 100个字符的空间的，如果是<code>varchar</code>这样的变长字段， <code>null</code> 不占用空间。</p><p>可以在<code>num</code>上设置默认值0，确保表中<code>num</code>列没有<code>null</code>值，然后这样查询：</p><p><code>mysqlselect id from t where num = 0</code>mysql</p><p>3.应尽量避免在 <code>where</code> 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>4.应尽量避免在 <code>where</code> 子句中使用 <code>or</code> 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：</p><p><code>mysqlselect id from t where num=10 or Name = &#39;admin&#39;</code>mysql</p><p>可以这样查询：</p><p><code>mysqlselect id from t where num = 10union allselect id from t where Name = &#39;admin&#39;</code>mysql</p><p>5.<code>in</code> 和 <code>not in</code> 也要慎用，否则会导致全表扫描，如：</p><p><code>mysqlselect id from t where num in(1,2,3)</code>mysql</p><p>对于连续的数值，能用 <code>between</code> 就不要用 <code>in</code> 了：</p><p><code>mysqlselect id from t where num between 1 and 3</code>mysql</p><p>很多时候用 <code>exists</code> 代替 <code>in</code> 是一个好的选择：</p><p><code>mysqlselect num from a where num in(select num from b)</code>mysql</p><p>用下面的语句替换：</p><p><code>mysqlselect num from a where exists(select 1 from b where num=a.num)</code>mysql</p><p>6.下面的查询也将导致全表扫描：</p><p><code>mysqlselect id from t where name like ‘%abc%’</code>mysql</p><p>若要提高效率，可以考虑全文检索。</p><p>7.如果在 <code>where</code> 子句中使用参数，也会导致全表扫描。因为<code>SQL</code>只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><p><code>mysqlselect id from t where num = @num</code>mysql</p><p>可以改为强制查询使用索引：</p><p><code>mysqlselect id from t with(index(索引名)) where num = @num</code>mysql</p><p>8.应尽量避免在 <code>where</code> 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><p><code>mysqlselect id from t where num/2 = 100</code>mysql</p><p>应改为:</p><p><code>mysqlselect id from t where num = 100*2</code>mysql</p><p>9.应尽量避免在<code>where</code>子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><p><code>mysqlselect id from t where substring(name,1,3) = ’abc’       -–name以abc开头的idselect id from t where datediff(day,createdate,’2005-11-30′) = 0    -–‘2005-11-30’    --生成的id</code>mysql</p><p>应改为:</p><p><code>mysqlselect id from t where name like &#39;abc%&#39;select id from t where createdate &gt;= &#39;2005-11-30&#39; and createdate &lt; &#39;2005-12-1&#39;</code>mysql</p><p>10.不要在 <code>where</code> 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12.不要写一些没有意义的查询，如需要生成一个空表结构：</p><p><code>mysqlselect col1,col2 into #t from t where 1=0</code>mysql</p><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><p><code>mysqlcreate table #t(…)</code>mysql</p><p>13.<code>Update</code> 语句，如果只更改1、2个字段，不要<code>Update</code>全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p><p>14.对于多张大数据量（这里几百条就算大了）的表<code>JOIN</code>，要先分页再<code>JOIN</code>，否则逻辑读会很高，性能很差。</p><p>15.<code>select count(*) from table；</code>这样不带任何条件的<code>count</code>会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</p><p>16.索引并不是越多越好，索引固然可以提高相应的 <code>select</code> 的效率，但同时也降低了 <code>insert</code> 及 <code>update</code> 的效率，因为 <code>insert</code> 或 <code>update</code> 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p><p>17.应尽可能的避免更新 <code>clustered</code> 索引数据列，因为 <code>clustered</code> 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 <code>clustered</code> 索引数据列，那么需要考虑是否应将该索引建为 <code>clustered</code> 索引。</p><p>18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>19.尽可能的使用 <code>varchar/nvarchar</code> 代替 <code>char/nchar</code> ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>20.任何地方都不要使用 <code>select * from t</code> ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>21.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>22.避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p><p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 <code>select into</code> 代替 <code>create table</code>，避免造成大量 <code>log</code> ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先<code>create table</code>，然后<code>insert</code>。</p><p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 <code>truncate table</code> ，然后 <code>drop table</code> ，这样可以避免系统表的较长时间锁定。</p><p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过<code>1</code>万行，那么就应该考虑改写。</p><p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>27.与临时表一样，游标并不是不可使用。对小型数据集使用 <code>FAST_FORWARD</code> 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><p>28.在所有的存储过程和触发器的开始处设置 <code>SET NOCOUNT ON</code> ，在结束时设置 <code>SET NOCOUNT OFF</code>。无需在执行存储过程和触发器的每个语句后向客户端发送 <code>DONE_IN_PROC</code> 消息。</p><p>29.尽量避免大事务操作，提高系统并发能力。</p><p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>实际案例分析：拆分大的 <code>DELETE</code> 或<code>INSERT</code> 语句，批量提交<code>SQL</code>语句</p><p>如果你需要在一个在线的网站上去执行一个大的 <code>DELETE</code> 或 <code>INSERT</code> 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</p><p><code>Apache</code> 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。</p><p>如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。</p><p>所以，如果你有一个大的处理，你一定把其拆分，使用 <code>LIMIT oracle(rownum),sqlserver(top)</code>条件是一个好的方法。下面是一个<code>mysql</code>示例：</p><p><code>`</code>mysql<br>while(1){</p><p> 　　//每次只做1000条</p><p>　　 mysql_query(“delete from logs where log_date &lt;= ’2012-11-01’ limit 1000”);</p><p> 　　if(mysql_affected_rows() == 0){</p><p>　　 　　//删除完成，退出！<br>　　 　　break；<br>　　}</p><p>//每次暂停一段时间，释放表让其他进程/线程访问。<br>usleep(50000)</p><p>}<br><code>`</code>mysql</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/6.jpg&quot; alt=&quot;hashmap&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="sql优化" scheme="https://lccsetsun.github.io/tags/sql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>HashMap实现原理及源码分析</title>
    <link href="https://lccsetsun.github.io/2019/05/19/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://lccsetsun.github.io/2019/05/19/HashMap实现原理及源码分析/</id>
    <published>2019-05-19T12:05:38.000Z</published>
    <updated>2019-06-07T07:02:56.502Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/2.jpg" alt="hashmap"></p><a id="more"></a><h1 id="HashMap实现原理及源码分析"><a href="#HashMap实现原理及源码分析" class="headerlink" title="HashMap实现原理及源码分析"></a>HashMap实现原理及源码分析</h1><p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p><p>目录</p><p>一、什么是哈希表</p><p>二、HashMap实现原理</p><p>三、为何HashMap的数组长度一定是2的次幂？</p><p>四、重写equals方法需同时重写hashCode方法</p><p>五、总结<br>一、什么是哈希表</p><p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p><p>数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)</p><p>线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)</p><p>二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</p><p>哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p><p>我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。</p><p>比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p><p>存储位置 = f(关键字)</p><p>其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p><p>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p><p>哈希冲突</p><p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式，<br>二、HashMap实现原理</p><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><p>//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。<br>transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</p><p>Entry是HashMap中的一个静态内部类。代码如下</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">    <span class="keyword">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates new entry.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以，HashMap的整体结构如下</p><p>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p><p>其他几个重要字段</p><p>//实际存储的key-value键值对的个数<br>transient int size;<br>//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到<br>int threshold;<br>//负载因子，代表了table的填充度有多少，默认是0.75<br>final float loadFactor;<br>//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException<br>transient int modCount;</p><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值</p><p>initialCapacity默认为16，loadFactory默认为0.75</p><p>我们看下其中一个</p><p>public HashMap(int initialCapacity, float loadFactor) {<br>//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230)<br>if (initialCapacity &lt; 0)<br>throw new IllegalArgumentException(“Illegal initial capacity: “ +<br>initialCapacity);<br>if (initialCapacity &gt; MAXIMUM_CAPACITY)<br>initialCapacity = MAXIMUM_CAPACITY;<br>if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))<br>throw new IllegalArgumentException(“Illegal load factor: “ +<br>loadFactor);</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this.loadFactor = loadFactor<span class="comment">;</span></span><br><span class="line">    threshold = initialCapacity<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现<br>}</p><p>从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</p><p>OK,接下来我们来看看put操作的实现吧<br><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);<span class="comment">//对key的hashcode进一步计算，确保散列均匀</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//获取在table中的实际位置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">    <span class="comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.<span class="keyword">equals</span>(k))) &#123;</span><br><span class="line">            V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">            e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;<span class="comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">    addEntry(hash, key, <span class="keyword">value</span>, i);<span class="comment">//新增一个entry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><p>先来看看inflateTable这个方法</p><p>private void inflateTable(int toSize) {<br>int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂<br>threshold = (int) Math.min(capacity _ loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity_loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1<br>table = new Entry[capacity];<br>initHashSeedAsNeeded(capacity);<br>}<br>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.<br>private static int roundUpToPowerOf2(int number) {<br>// assert number &gt;= 0 : “number must be non-negative”;<br>return number &gt;= MAXIMUM_CAPACITY<br>? MAXIMUM_CAPACITY<br>: (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;<br>}<br>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值.<br>hash函数<br>//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀<br>final int hash(Object k) {<br>int h = hashSeed;<br>if (0 != h &amp;&amp; k instanceof String) {<br>return sun.misc.Hashing.stringHash32((String) k);<br>}</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">h</span><span class="regexp"> ^=</span> k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">20</span>)<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="attribute">return</span> h<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">7</span>)<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置<br>/*<em><br></em> 返回数组下标<br>*/<br>static int indexFor(int h, int length) {<br>return h &amp; (length-1);<br>}</p><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line">&amp;   <span class="number">0</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span></span><br><span class="line">__________________</span><br><span class="line">    <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>    = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算）</p><p>所以最终存储位置的确定流程是这样的：<br>再来看看addEntry的实现：<br>void addEntry(int hash, K key, V value, int bucketIndex) {<br>if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {<br>resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容<br>hash = (null != key) ? hash(key) : 0;<br>bucketIndex = indexFor(hash, table.length);<br>}</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createEntry(hash, <span class="built_in">key</span>, <span class="built_in">value</span>, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。<br>三、为何HashMap的数组长度一定是2的次幂？<br>我们来继续看上面提到的resize方法<br>void resize(int newCapacity) {<br>Entry[] oldTable = table;<br>int oldCapacity = oldTable.length;<br>if (oldCapacity == MAXIMUM_CAPACITY) {<br>threshold = Integer.MAX_VALUE;<br>return;<br>}</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry[] <span class="keyword">new</span><span class="type">Table</span> = <span class="keyword">new</span> <span class="type">Entry</span>[<span class="keyword">new</span><span class="type">Capacity</span>];</span><br><span class="line">    transfer(<span class="keyword">new</span><span class="type">Table</span>, initHashSeedAsNeeded(<span class="keyword">new</span><span class="type">Capacity</span>));</span><br><span class="line">    table = <span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line">    threshold = (int)Math.min(<span class="keyword">new</span><span class="type">Capacity</span> * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法<br>void transfer(Entry[] newTable, boolean rehash) {<br>int newCapacity = newTable.length;<br>//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）<br>for (Entry&lt;K,V&gt; e : table) {<br>while(null != e) {<br>Entry&lt;K,V&gt; next = e.next;<br>if (rehash) {<br>e.hash = null == e.key ? 0 : hash(e.key);<br>}<br>int i = indexFor(e.hash, newCapacity);<br>//将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。<br>e.next = newTable[i];<br>newTable[i] = e;<br>e = next;<br>}<br>}</p><p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。</p><p>hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。</p><p>还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如：</p><p>我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。</p><p>如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。</p><p>get方法<br>public V get(Object key) {<br>//如果key为null,则直接去table[0]处去检索即可。<br>if (key == null)<br>return getForNullKey();<br>Entry&lt;K,V&gt; entry = getEntry(key);<br>return null == entry ? null : entry.getValue();<br>}<br>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法<br>final Entry&lt;K,V&gt; getEntry(Object key) {</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过key的hashcode值计算hash值</span></span><br><span class="line">    <span class="built_in">int</span> hash = (<span class="built_in">key</span> == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(<span class="built_in">key</span>);</span><br><span class="line">    <span class="comment">//indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        <span class="keyword">Object</span> k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">            ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || (<span class="built_in">key</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">key</span>.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。<br>四、重写equals方法需同时重写hashCode方法</p><p>关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题<br>复制代码</p><p>/**</p><ul><li>Created by chengxiao on 2016/11/15.<br>*/<br>public class MyTest {<br>private static class Person{<br>int idCard;<br>String name;<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Person(int idCard, String name) &#123;</span><br><span class="line">     <span class="keyword">this</span>.idCard = idCard;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> boolean equals(Object o) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass())&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     Person person = (Person) o;</span><br><span class="line">     <span class="comment">//两个对象是否等值，通过idCard来确定</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.idCard == person.idCard;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>}<br>public static void main(String []args){<br>HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();<br>Person person = new Person(1234,”乔峰”);<br>//put到hashmap中去<br>map.put(person,”天龙八部”);<br>//get取出，从逻辑上讲应该能输出“天龙八部”<br>System.out.println(“结果:”+map.get(new Person(1234,”萧峰”)));<br>}<br>}</p><p>实际输出结果：</p><p>结果：null</p><p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。）</p><p>所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/2.jpg&quot; alt=&quot;hashmap&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="hashmap" scheme="https://lccsetsun.github.io/tags/hashmap/"/>
    
      <category term="hashEntry" scheme="https://lccsetsun.github.io/tags/hashEntry/"/>
    
      <category term="二进制" scheme="https://lccsetsun.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="红黑树" scheme="https://lccsetsun.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg常用命令</title>
    <link href="https://lccsetsun.github.io/2019/05/11/ffmpeg/"/>
    <id>https://lccsetsun.github.io/2019/05/11/ffmpeg/</id>
    <published>2019-05-11T12:05:38.000Z</published>
    <updated>2019-06-07T07:02:33.062Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/1.jpg" alt="ffmpeg"></p><a id="more"></a><h2 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h2><h3 id="桌面录制"><a href="#桌面录制" class="headerlink" title="桌面录制"></a>桌面录制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -i <span class="string">"1"</span> -vcodec libx264 -preset ultrafast -acodec libfaac -f flv ~/Movies/output.flv</span><br></pre></td></tr></table></figure><h3 id="摄像头录制"><a href="#摄像头录制" class="headerlink" title="摄像头录制"></a>摄像头录制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f avfoundation -framerate <span class="number">30</span> -i <span class="string">"0:0"</span> -vcodec libx264 -preset veryfast -f flv test.mkv</span><br></pre></td></tr></table></figure><h3 id="将ts流转h264裸流"><a href="#将ts流转h264裸流" class="headerlink" title="将ts流转h264裸流"></a>将ts流转h264裸流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.ts -c:v libx264 h264test.h264</span><br></pre></td></tr></table></figure><h3 id="将ts流转mp4"><a href="#将ts流转mp4" class="headerlink" title="将ts流转mp4"></a>将ts流转mp4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i <span class="number">1047</span>.ts -vcodec copy -f mp4 <span class="number">1047</span>.mp4</span><br></pre></td></tr></table></figure><h3 id="拼接视频"><a href="#拼接视频" class="headerlink" title="拼接视频"></a>拼接视频</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备avi.txt. </span></span><br><span class="line">vim avi.txt</span><br><span class="line"><span class="number">1</span>.mp4</span><br><span class="line"><span class="number">2</span>.mp4</span><br><span class="line">ffmpeg -f concat -safe <span class="number">0</span> -<span class="selector-tag">i</span> avi<span class="selector-class">.txt</span> -c copy output.mp4</span><br></pre></td></tr></table></figure><h3 id="截取指定位置的图片"><a href="#截取指定位置的图片" class="headerlink" title="截取指定位置的图片"></a>截取指定位置的图片</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ffmpeg</span> <span class="selector-tag">-ss</span> 00<span class="selector-pseudo">:02</span><span class="selector-pseudo">:06</span> <span class="selector-tag">-i</span> <span class="selector-tag">test1</span><span class="selector-class">.flv</span> <span class="selector-tag">-f</span> <span class="selector-tag">image2</span> <span class="selector-tag">-y</span> <span class="selector-tag">test1</span><span class="selector-class">.jpg</span></span><br></pre></td></tr></table></figure><h2 id="FFMPEG推流到RTMP服务器命令"><a href="#FFMPEG推流到RTMP服务器命令" class="headerlink" title="FFMPEG推流到RTMP服务器命令"></a>FFMPEG推流到RTMP服务器命令</h2><h3 id="将文件当作源推送到RTMP服务器"><a href="#将文件当作源推送到RTMP服务器" class="headerlink" title="将文件当作源推送到RTMP服务器"></a>将文件当作源推送到RTMP服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i localFile.mp4 -c copy -f flv rtmp:<span class="comment">//server/live/streamName</span></span><br></pre></td></tr></table></figure><ul><li>参数解释<br>-r 以本地帧频读数据，主要用于模拟捕获设备。表示ffmpeg将按照帧率发送数据，不会按照最高的效率发送</li></ul><h3 id="将直播文件保存至本地"><a href="#将直播文件保存至本地" class="headerlink" title="将直播文件保存至本地"></a>将直播文件保存至本地</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:<span class="comment">//server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><h3 id="将其中一个直播流中的视频改用H-264压缩，音频不变，推送到另外一个直播服务器"><a href="#将其中一个直播流中的视频改用H-264压缩，音频不变，推送到另外一个直播服务器" class="headerlink" title="将其中一个直播流中的视频改用H.264压缩，音频不变，推送到另外一个直播服务器"></a>将其中一个直播流中的视频改用H.264压缩，音频不变，推送到另外一个直播服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:<span class="comment">//server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv rtmp://server/live/h264Stream</span></span><br></pre></td></tr></table></figure><h3 id="将其中一个直播流中的视频改用H-264压缩，音频改用aac压缩，推送到另外一个直播服务器"><a href="#将其中一个直播流中的视频改用H-264压缩，音频改用aac压缩，推送到另外一个直播服务器" class="headerlink" title="将其中一个直播流中的视频改用H.264压缩，音频改用aac压缩，推送到另外一个直播服务器"></a>将其中一个直播流中的视频改用H.264压缩，音频改用aac压缩，推送到另外一个直播服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:<span class="comment">//server/live/originalStream -c:a libfaac -ar 44100 -ab 48k -c:v libx264 -vpre slow -vpre baseline -f flv rtmp://server/live/h264Stream</span></span><br></pre></td></tr></table></figure><h3 id="将其中一个直播流中的视频不变，音频改用aac压缩，推送到另外一个直播服务器"><a href="#将其中一个直播流中的视频不变，音频改用aac压缩，推送到另外一个直播服务器" class="headerlink" title="将其中一个直播流中的视频不变，音频改用aac压缩，推送到另外一个直播服务器"></a>将其中一个直播流中的视频不变，音频改用aac压缩，推送到另外一个直播服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp:<span class="comment">//server/live/originalStream -acodec libfaac -ar 44100 -ab 48k -vcodec copy -f flv rtmp://server/live/h264_AAC_Stream</span></span><br></pre></td></tr></table></figure><h3 id="将一个高清流复制为几个不同清晰度的流重新发布，其中音频不变"><a href="#将一个高清流复制为几个不同清晰度的流重新发布，其中音频不变" class="headerlink" title="将一个高清流复制为几个不同清晰度的流重新发布，其中音频不变"></a>将一个高清流复制为几个不同清晰度的流重新发布，其中音频不变</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i rtmp:<span class="comment">//server/live/high_FMLE_stream -acodec copy -vcodec x264lib -s 640×360 -b 500k -vpre medium -vpre baseline rtmp://server/live/baseline_500k -acodec copy -vcodec x264lib -s 480×272 -b 300k -vpre medium -vpre baseline rtmp://server/live/baseline_300k -acodec copy -vcodec x264lib -s 320×200 -b 150k -vpre medium -vpre baseline rtmp://server/live/baseline_150k -acodec libfaac -vn -ab 48k rtmp://server/live/audio_only_AAC_48k</span></span><br></pre></td></tr></table></figure><h3 id="将当前摄像头以及扬声器通过DSHOW采集，使用H-264-AAC压缩后推送到RTMP服务器"><a href="#将当前摄像头以及扬声器通过DSHOW采集，使用H-264-AAC压缩后推送到RTMP服务器" class="headerlink" title="将当前摄像头以及扬声器通过DSHOW采集，使用H.264/AAC压缩后推送到RTMP服务器"></a>将当前摄像头以及扬声器通过DSHOW采集，使用H.264/AAC压缩后推送到RTMP服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -r <span class="number">25</span> -f dshow -s <span class="number">640</span>×<span class="number">480</span> -i video=”video source name”:audio=”audio source name” -vcodec libx264 -b <span class="number">600</span>k -vpre slow -acodec libfaac -ab <span class="number">128</span>k -f flv rtmp:<span class="comment">//server/application/stream_name</span></span><br></pre></td></tr></table></figure><h3 id="将一个JPG图片经过H-264压缩后输出为MP4文件"><a href="#将一个JPG图片经过H-264压缩后输出为MP4文件" class="headerlink" title="将一个JPG图片经过H.264压缩后输出为MP4文件"></a>将一个JPG图片经过H.264压缩后输出为MP4文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i INPUT.jpg -an -vcodec libx264 -coder <span class="number">1</span> -flags +loop -cmp +chroma -subq <span class="number">10</span> -qcomp <span class="number">0.6</span> -qmin <span class="number">10</span> -qmax <span class="number">51</span> -qdiff <span class="number">4</span> -flags2 +dct8x8 -trellis <span class="number">2</span> -partitions +parti8x8+parti4x4 -crf <span class="number">24</span> -threads <span class="number">0</span> -r <span class="number">25</span> -g <span class="number">25</span> -y OUTPUT.mp4</span><br></pre></td></tr></table></figure><h3 id="将MP3转化为AAC"><a href="#将MP3转化为AAC" class="headerlink" title="将MP3转化为AAC"></a>将MP3转化为AAC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i <span class="number">20120814164324_205</span>.wav -acodec  libfaac -ab <span class="number">64</span>k -ar <span class="number">44100</span>  output.aac</span><br></pre></td></tr></table></figure><h3 id="将AAC文件转化为flv文件，编码格式采用AAC"><a href="#将AAC文件转化为flv文件，编码格式采用AAC" class="headerlink" title="将AAC文件转化为flv文件，编码格式采用AAC"></a>将AAC文件转化为flv文件，编码格式采用AAC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i output.aac -acodec libfaac -y -ab <span class="number">32</span> -ar <span class="number">44100</span> -qscale <span class="number">10</span> -s <span class="number">640</span>*<span class="number">480</span> -r <span class="number">15</span> output.flv</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/1.jpg&quot; alt=&quot;ffmpeg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ffmpeg" scheme="https://lccsetsun.github.io/tags/ffmpeg/"/>
    
      <category term="ffplay" scheme="https://lccsetsun.github.io/tags/ffplay/"/>
    
      <category term="video" scheme="https://lccsetsun.github.io/tags/video/"/>
    
  </entry>
  
  <entry>
    <title>java8的Stream特性</title>
    <link href="https://lccsetsun.github.io/2019/05/11/Java8_school/"/>
    <id>https://lccsetsun.github.io/2019/05/11/Java8_school/</id>
    <published>2019-05-11T08:47:28.000Z</published>
    <updated>2019-06-07T06:45:43.315Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/java8.jpg" alt="java8"></p><a id="more"></a><h1 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h1><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>写这个文档的主要原因是自己使用java8时间并不长，对java的认知还停留在java6的基础上，很多新功能是：然也，知之不详；所以然也，不知。 所有平时就抽一些时间出来，做些记录和总结，就形成了这个文档，权当学习笔记之用。</p><h1 id="2-Lambda"><a href="#2-Lambda" class="headerlink" title="2. Lambda"></a>2. Lambda</h1><h2 id="（1）什么是Lambda"><a href="#（1）什么是Lambda" class="headerlink" title="（1）什么是Lambda?"></a>（1）什么是Lambda?</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda是从数学中的<span class="built_in">lambda</span>运算引申出来的，在计算机中主要指匿名函数，也是函数式编程的核心。你可能会问什么是函数式编程，它与命令式编程不同在哪里？ 笼统的来说，函数式编程关心的数据映射的问题，命令式编程更关心的是解决问题的步骤。</span><br></pre></td></tr></table></figure><h2 id="（2）Lambda基本语法"><a href="#（2）Lambda基本语法" class="headerlink" title="（2）Lambda基本语法"></a>（2）Lambda基本语法</h2><p>lambda表达式主要包括三部分：Argument List, Arrow, Body<br><br>对应的比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x+y</span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure><h3 id="a-简单示例"><a href="#a-简单示例" class="headerlink" title="(a) 简单示例"></a>(a) 简单示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"hello  runnable"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable r2 = ()-&gt;System.out.println(<span class="string">"hello lambda runner"</span>);</span><br><span class="line">        r1.run();</span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码反应了两个情况，一是lambda确实简洁，之前要6行代码做的事情，lambda一行就搞定了；二是其实lambda并没有引入新东西，lambda做的事情，用普通的java也能做，只是效率没那么高而已。</p><p>当然还有别的原因，在集合的处理上，lambda表达式能简化多线程或者多核的处理，这也是java8打动人的原因。</p><h3 id="b-Comparator"><a href="#b-Comparator" class="headerlink" title="(b) Comparator"></a>(b) Comparator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List &lt;Car&gt; carList = LambdaTest.buildCarList();</span><br><span class="line">        System.out.println(<span class="string">"\n=== Sorted with normal java ASC ==="</span>);</span><br><span class="line">        Collections.sort(carList, <span class="keyword">new</span> Comparator &lt;Car&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span> <span class="params">(Car o1, Car o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getPrice() - o2.getPrice();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Car car : carList) &#123;</span><br><span class="line">            System.out.print(car.getPrice() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n=== Sorted with lambda ASC ==="</span>);</span><br><span class="line">        Collections.sort(carList, (Car car1, Car car2) -&gt; (car1.getPrice() - car2.getPrice()));</span><br><span class="line">        <span class="keyword">for</span> (Car car : carList) &#123;</span><br><span class="line">            System.out.print(car.getPrice() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"\n=== Sorted with lambda DESC ==="</span>);</span><br><span class="line">        Collections.sort(carList, (car1,  car2) -&gt; (car2.getPrice() - car1.getPrice()));</span><br><span class="line">        carList.forEach(c -&gt; System.out.print(c.getPrice() + <span class="string">" "</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中也明显可以看出，使用Lambda做一些自定义的排序，更为灵活简便。升序和降序只用改变一下位置就可以。注意降序排列跟升序排的写法并不一致，<br><br><code>Collections.sort(carList, (car1, car2) -&gt; (car2.getPrice() - car1.getPrice()));</code></p><p><strong>lambda会自动做参数类型推导，所以写的时候省略也是参数类型可以的！</strong><br><br><strong>遍历list用了forEach</strong><br><br><code>carList.forEach(c -&gt; System.out.print(c.getPrice() + &quot; &quot;));</code></p><h3 id="c-的使用"><a href="#c-的使用" class="headerlink" title="(c) ::的使用"></a>(c) <code>::</code>的使用</h3><p>使用<code>::</code>有三种方式</p><ul><li>object::instanceMethod</li><li>Class::staticMethod</li><li>Class::instanceMethod</li></ul><ol><li>第一种方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentGreeter</span> <span class="keyword">extends</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">super</span>::greet);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ConcurrentGreeter().greet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码运行后，会调用父类Greeter的greet方法<br></p><ol start="2"><li>第二种方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>上述代码也等价与<code>list.forEach(l -&gt; System.out.println(l));</code></p><ol start="3"><li>第三种方式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; labels = ...;</span><br><span class="line">Stream&lt;Button&gt; stream = labels.stream().map(Button::<span class="keyword">new</span>); </span><br><span class="line">List&lt;Button&gt; buttons = stream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>stream也是java8中的核心内容之一，第二章仔细介绍类stream的用法。</p><h3 id="Lambda最佳实践"><a href="#Lambda最佳实践" class="headerlink" title="Lambda最佳实践"></a>Lambda最佳实践</h3><p>待补充</p><h1 id="2-Stream（流）"><a href="#2-Stream（流）" class="headerlink" title="2. Stream（流）"></a>2. Stream（流）</h1><h3 id="a-简介"><a href="#a-简介" class="headerlink" title="(a)简介"></a>(a)简介</h3><p>stream也叫流，大概是java8最受追捧和欢迎的特性，stream最大的特点有两个：</p><ul><li>代码简介，函数式编程的的写法让代码更易读的同时，长度也缩短了很多</li><li>多核友好， 程序员几乎不用关心串并行的事儿，吃着火锅，唱着歌就能写出高效率的代码。</li></ul><h3 id="b-stream是如何工作的"><a href="#b-stream是如何工作的" class="headerlink" title="(b) stream是如何工作的"></a>(b) stream是如何工作的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List &lt;String&gt; myList =</span><br><span class="line">            Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>, <span class="string">"c5"</span>, <span class="string">"c3"</span>);</span><br><span class="line"></span><br><span class="line">        myList</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">"c"</span>))</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>流函数有两种类型，一种是中间类型，一种是终止类型，中间类型返回一个stream对象方便大家做优雅的链式调用，终止类型或者说终端类型是返回一个对象或者是吗都不返回，比如List或者map等等。总而言之，stream到这个函数就终止了，所以叫终止类型。</p><p>上述例子中， filter, map, sorted就是中间类型， forEach就是终止类型。<br><br>大部分stream函数是接受lambda作为参数的， 其实也容易理解，要用lambda定义这个流函数具体要做什么，filter是做过滤，但具体怎么做，过滤哪些，留下哪些？都是要lambda来定义，当然可以用java函数代替，但明显没有lambda优雅，可读性高，这也是为什么要用labmda的原因之一。</p><p><strong>注意，不要在流函数中，改变集合，比如增加或者删除元素。</strong></p><h3 id="c-stream类型介绍"><a href="#c-stream类型介绍" class="headerlink" title="(c) stream类型介绍"></a>(c) stream类型介绍</h3><p>流可以从串并行的缴费可以分为stream和parallelStream，即串行流和并行流，但其实一种stream.从类型上有可以分几类，创建方式如下：</p><ol><li>第一种也是最常见的一种是通过List,Set等对象的stream()方法，获取stream</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .findFirst()</span><br><span class="line">            .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><ol start="2"><li>通过Stream.of()函数创建流</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>)</span><br><span class="line">  .findFirst()</span><br><span class="line">  .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><ol start="3"><li>java8也定义了几种基础类型的流， 比如IntStream, LongStream, DoubleStream</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>基础类型的流跟对象流的用法相同又有所不同，相同之处是他们都继承自BaseStream。 不同之处是部分函数参数有所不同， 比如IntStream使用IntFunction而不是Function, 用IntPredicate而不是Predicate； 基础类型的流支持一些聚合流函数，比如sum, average等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">            .map(n -&gt; <span class="number">2</span> * n + <span class="number">1</span>)</span><br><span class="line">            .average()</span><br><span class="line">            .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>不同的流类型之间也可以做转换, 比如IntStream可以转为DoubleStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>,<span class="number">10</span>).mapToDouble(Double::<span class="keyword">new</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>对象流可以转换为基础类型流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"a12"</span>, <span class="string">"a23"</span>, <span class="string">"a34"</span>)</span><br><span class="line">.map(s -&gt; s.substring(<span class="number">1</span>))</span><br><span class="line">.mapToInt(Integer::parseInt)</span><br><span class="line">.max()</span><br><span class="line">.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>基础类型流可以转换为对象流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">.mapToObj(i -&gt; <span class="string">"a"</span> + i)</span><br><span class="line">.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p><em>360度前空翻转体两周半</em>流类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">.mapToInt(Double::intValue)</span><br><span class="line">.mapToObj(i -&gt; <span class="string">"a"</span> + i)</span><br><span class="line">.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="d-流函数执行顺序"><a href="#d-流函数执行顺序" class="headerlink" title="(d) 流函数执行顺序"></a>(d) 流函数执行顺序</h3><p>流的本质跟sql有些类似，即使是为了获取相同的数据，不同的写法效率也大大不同。<br><br>先看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">.map(s -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line"><span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">&#125;)</span><br><span class="line">.filter(s -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line"><span class="keyword">return</span> s.startsWith(<span class="string">"A"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br></pre></td></tr></table></figure><p>这个的输出结果是</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">map:</span> d2</span><br><span class="line"><span class="symbol">filter:</span> D2</span><br><span class="line"><span class="symbol">map:</span> a2</span><br><span class="line"><span class="symbol">filter:</span> A2</span><br><span class="line"><span class="symbol">forEach:</span> A2</span><br><span class="line"><span class="symbol">map:</span> b1</span><br><span class="line"><span class="symbol">filter:</span> B1</span><br><span class="line"><span class="symbol">map:</span> b3</span><br><span class="line"><span class="symbol">filter:</span> B3</span><br><span class="line"><span class="symbol">map:</span> c</span><br><span class="line"><span class="symbol">filter:</span> C</span><br></pre></td></tr></table></figure><p>如果改变下顺序呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">.filter(s -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"filter: "</span> + s);</span><br><span class="line">  <span class="keyword">return</span> s.startsWith(<span class="string">"a"</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.map(s -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">"map: "</span> + s);</span><br><span class="line">  <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">&#125;)</span><br><span class="line">.forEach(s -&gt; System.out.println(<span class="string">"forEach: "</span> + s));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">filter:</span> d2</span><br><span class="line"><span class="symbol">filter:</span> a2</span><br><span class="line"><span class="symbol">map:</span> a2</span><br><span class="line"><span class="symbol">forEach:</span> A2</span><br><span class="line"><span class="symbol">filter:</span> b1</span><br><span class="line"><span class="symbol">filter:</span> b3</span><br><span class="line"><span class="symbol">filter:</span> c</span><br></pre></td></tr></table></figure><p>map跟forEach仅执行了一次</p><h3 id="e-stream复用"><a href="#e-stream复用" class="headerlink" title="(e) stream复用"></a>(e) stream复用</h3><p>正常情况下stream是不能被复用的，运行下面代码会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =</span><br><span class="line">  Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">  .filter(s -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">stream.anyMatch(s -&gt; <span class="keyword">true</span>);    </span><br><span class="line">stream.noneMatch(s -&gt; <span class="keyword">true</span>);   </span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">229</span>)</span><br><span class="line">    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="number">459</span>)</span><br><span class="line">    at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="number">38</span>)</span><br><span class="line">    at com.winterbe.java8.Streams5.main(Streams5.java:<span class="number">28</span>)</span><br></pre></td></tr></table></figure><p>复用的办法是使用supplier每次都构建一个新的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =</span><br><span class="line">    () -&gt; Stream.of(<span class="string">"d2"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"b3"</span>, <span class="string">"c"</span>)</span><br><span class="line">            .filter(s -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">streamSupplier.get().anyMatch(s -&gt; <span class="keyword">true</span>);   </span><br><span class="line">streamSupplier.get().noneMatch(s -&gt; <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="f-stream进阶"><a href="#f-stream进阶" class="headerlink" title="(f) stream进阶"></a>(f) stream进阶</h3><p>除了上面例子中用到的filer,map, forEach等还有一些也是会用到的流函数，先构造一个对象List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons =</span><br><span class="line">    Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Paomo"</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Linzhi"</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Wenhe"</span>, <span class="number">23</span>),</span><br><span class="line">        <span class="keyword">new</span> Person(<span class="string">"Shenlv"</span>, <span class="number">12</span>));</span><br></pre></td></tr></table></figure><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p>collect是比较常用的流终止函数，与<code>Collectors</code>类搭配使用，奇妙无穷。<br><br>获取Person中name以”P”开头的人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; filtered =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .filter(p -&gt; p.name.startsWith(<span class="string">"P"</span>))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">System.out.println(filtered);  <span class="comment">// Paomo</span></span><br></pre></td></tr></table></figure><p>当然也可以获取Set，使用<code>Collectors.toSet()</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.groupingBy(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">personsByAge</span><br><span class="line">    .forEach((age, p) -&gt; System.out.format(<span class="string">"age %s: %s\n"</span>, age, p));</span><br></pre></td></tr></table></figure><p>collect好像还好，但groupingBy一开始看有点晕，看下函数源码知道传入的lambda，是作为classfier把item映射成key， collect是会返回Person.age为key, 如果Person年纪相同，会放入同一个list当中。<br>最后得到结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age <span class="number">18</span>: [Paomo]</span><br><span class="line">age <span class="number">23</span>: [Linzhi, Wenhe]</span><br><span class="line">age <span class="number">12</span>: [Shenlv]</span><br></pre></td></tr></table></figure><p>Collectors非常灵活，如果你想计算这些Person的平均年龄：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Double averageAge = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.averagingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(averageAge);</span><br></pre></td></tr></table></figure><p>获取这些人的一些统计数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics ageSummary =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(Collectors.summarizingInt(p -&gt; p.age));</span><br><span class="line"></span><br><span class="line">System.out.println(ageSummary);</span><br><span class="line"><span class="comment">//IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125;</span></span><br></pre></td></tr></table></figure><p>所有人拼接成一个字符串输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String phrase = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.age &gt;= <span class="number">18</span>)</span><br><span class="line">    .map(p -&gt; p.name)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">" and "</span>, <span class="string">"In China,"</span>, <span class="string">" are of legal age."</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(phrase);</span><br><span class="line"><span class="comment">//output: In China, Paomo and Linzhi and Wenhe are of legal age.</span></span><br></pre></td></tr></table></figure><p>joining的三个参数，第一个为分隔符，第二个为前缀，第三个为后缀。<br><br>Person转换为map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(Collectors.toMap(</span><br><span class="line">        p -&gt; p.age,</span><br><span class="line">        p -&gt; p.name,</span><br><span class="line">        (name1, name2) -&gt; name1 + <span class="string">";"</span> + name2));</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><p>toMap传入的第三个参数是mergeFunction, 即当key相同时，把value合并的函数。可以自定Collector，完成一些定制化的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;Person, StringJoiner, String&gt; personNameCollector =</span><br><span class="line">    Collector.of(</span><br><span class="line">        () -&gt; <span class="keyword">new</span> StringJoiner(<span class="string">" | "</span>),          </span><br><span class="line">        (j, p) -&gt; j.add(p.name.toUpperCase()),  </span><br><span class="line">        (j1, j2) -&gt; j1.merge(j2),               </span><br><span class="line">        StringJoiner::toString);                </span><br><span class="line"></span><br><span class="line">String names = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(personNameCollector);</span><br><span class="line"><span class="comment">//output: PAOMO | LINZHI | WENHE | SHENLV</span></span><br></pre></td></tr></table></figure><p>collector里面要传4个参数，分别的supplier, accumulator, combiner和finisher, 关于这几个函数具体含义后面会有更详细的介绍。但是可以看出collect使用起来非常非常灵活。</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce会将stream中的所有元素combine到一块儿，形成一个最终结果。reduce函数有三种重载形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, </span></span></span><br><span class="line"><span class="function"><span class="params"> BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator, </span></span></span><br><span class="line"><span class="function"><span class="params"> BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure><p>BinaryOperator，BinaryOperator其实是继承自BiFunction，主要是两种相同类型的参数，经过运算产生一个相同类型的结果的运算符；BiFunction定义类似，是接收两个参数，产生一个结果的函数。</p><p>第一种方式，获取年纪最大的人，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2)</span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>第二种调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person result =</span><br><span class="line">    persons</span><br><span class="line">        .stream()</span><br><span class="line">        .reduce(<span class="keyword">new</span> Person(<span class="string">""</span>, <span class="number">0</span>), (p1, p2) -&gt; &#123;</span><br><span class="line">            p1.age += p2.age;</span><br><span class="line">            p1.name += p2.name;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//name=PaomoLinzhiWenheShenlv; age=76</span></span><br></pre></td></tr></table></figure><p>上面方法返回的是一个年纪为list中所有person的age之和，name为所有人名字的拼接结果</p><p>第三种调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .stream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s\n"</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s\n"</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Paomo</span></span><br><span class="line"><span class="comment">//accumulator: sum=18; person=Linzhi</span></span><br><span class="line"><span class="comment">//accumulator: sum=41; person=Wenhe</span></span><br><span class="line"><span class="comment">//accumulator: sum=64; person=Shenlv</span></span><br></pre></td></tr></table></figure><p>啊？ reduce只调用了accumulator没调用combiner? 其实这是因为combiner是在串行流中才会用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s\n"</span>, sum, p);</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s\n"</span>, sum1, sum2);</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Wenhe</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Paomo</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Linzhi</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Shenlv</span></span><br><span class="line"><span class="comment">//combiner: sum1=23; sum2=12</span></span><br><span class="line"><span class="comment">//combiner: sum1=18; sum2=23</span></span><br><span class="line"><span class="comment">//combiner: sum1=41; sum2=35</span></span><br></pre></td></tr></table></figure><p>accumulator是并行被调用所以需要combiner把accumalotr中的值归并累加。</p><h3 id="g-Parallel-Streams（并行流）"><a href="#g-Parallel-Streams（并行流）" class="headerlink" title="(g) Parallel Streams（并行流）"></a>(g) Parallel Streams（并行流）</h3><p>面对数据量比较大的情况，可以使用parallelStream，以充分利用系统的多核和性能，可以使用如下代码获取到当前的并行线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool commonPool = ForkJoinPool.commonPool();</span><br><span class="line">System.out.println(commonPool.getParallelism());  </span><br><span class="line"><span class="comment">//output: 7</span></span><br></pre></td></tr></table></figure><p>针对上面那个例子，我们可以看下，到底每个操作是在哪个线程中执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">persons</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .reduce(<span class="number">0</span>,</span><br><span class="line">        (sum, p) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"accumulator: sum=%s; person=%s [%s]\n"</span>,</span><br><span class="line">                sum, p, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum += p.age;</span><br><span class="line">        &#125;,</span><br><span class="line">        (sum1, sum2) -&gt; &#123;</span><br><span class="line">            System.out.format(<span class="string">"combiner: sum1=%s; sum2=%s [%s]\n"</span>,</span><br><span class="line">                sum1, sum2, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Wenhe [main]</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Shenlv [ForkJoinPool.commonPool-worker-6]</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Linzhi [ForkJoinPool.commonPool-worker-5]</span></span><br><span class="line"><span class="comment">//accumulator: sum=0; person=Paomo [ForkJoinPool.commonPool-worker-2]</span></span><br><span class="line"><span class="comment">//combiner: sum1=23; sum2=12 [ForkJoinPool.commonPool-worker-6]</span></span><br><span class="line"><span class="comment">//combiner: sum1=18; sum2=23 [ForkJoinPool.commonPool-worker-2]</span></span><br><span class="line"><span class="comment">//combiner: sum1=41; sum2=35 [ForkJoinPool.commonPool-worker-2]</span></span><br></pre></td></tr></table></figure><p>可以看出accumulator和combiner都是并行执行的。</p><h1 id="3-新增API"><a href="#3-新增API" class="headerlink" title="3. 新增API"></a>3. 新增API</h1><h2 id="1-时间处理"><a href="#1-时间处理" class="headerlink" title="(1) 时间处理"></a>(1) 时间处理</h2><p>原来时间处理函数存在的问题：</p><ul><li>线程安全: Date和Calendar不是线程安全的，你需要编写额外的代码处理线程安全问题</li><li>API设计和易用性: 由于Date和Calendar的设计不当你无法完成日常的日期操作</li><li>ZonedDate和Time: 你必须编写额外的逻辑处理时区和那些旧的逻辑</li></ul><h3 id="a-获取当前日期"><a href="#a-获取当前日期" class="headerlink" title="(a) 获取当前日期"></a>(a) 获取当前日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"localDate: "</span> + LocalDate.now());</span><br></pre></td></tr></table></figure><h3 id="b-判断是否为闰年"><a href="#b-判断是否为闰年" class="headerlink" title="(b) 判断是否为闰年"></a>(b) 判断是否为闰年</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leap year</span></span><br><span class="line">        System.out.println(<span class="string">"is leap year: LocalDate.now()"</span> + LocalDate.now().isLeapYear());</span><br></pre></td></tr></table></figure><h3 id="c-日期比较"><a href="#c-日期比较" class="headerlink" title="(c) 日期比较"></a>(c) 日期比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// time comparison</span></span><br><span class="line">        <span class="keyword">boolean</span> isBefore = LocalDate.parse(<span class="string">"2018-02-20"</span>)</span><br><span class="line">            .isBefore(LocalDate.parse(<span class="string">"2018-01-22"</span>));</span><br><span class="line">        System.out.println(<span class="string">"isBefore: "</span> + isBefore);</span><br><span class="line">        <span class="keyword">boolean</span> isAfter = LocalDate.parse(<span class="string">"2018-02-20"</span>).isAfter(LocalDate.parse(<span class="string">"2018-01-22"</span>));</span><br><span class="line">        System.out.println(<span class="string">"isAfter: "</span> + isAfter);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first day or last day of the month</span></span><br><span class="line">        LocalDate lastDayOfMonth = LocalDate.parse(<span class="string">"2018-02-20"</span>)</span><br><span class="line">            .with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        System.out.println(<span class="string">"Last Day of 2018/07: "</span> + lastDayOfMonth);</span><br></pre></td></tr></table></figure><h3 id="d-日期格式化"><a href="#d-日期格式化" class="headerlink" title="(d) 日期格式化"></a>(d) 日期格式化</h3><p>string format容易被忽视，但是也很重要<br><br><code>yyyy是指当天所在的年份， YYYY是指当前周所在的年份。</code><br><br>如果不注意跨年可能出现bug（<a href="https://www.atatech.org/articles/97733）" target="_blank" rel="noopener">https://www.atatech.org/articles/97733）</a><br><br><code>MM是月份， mm是分钟</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// format date</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        System.out.println(<span class="string">"default time format: "</span> + now);</span><br><span class="line">        System.out.println(<span class="string">"custom time format: "</span> + now.format(dateTimeFormatter));</span><br></pre></td></tr></table></figure><h3 id="e-计算时间间隔"><a href="#e-计算时间间隔" class="headerlink" title="(e) 计算时间间隔"></a>(e) 计算时间间隔</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime finalDate = LocalDateTime.now().plus(Period.ofDays(<span class="number">10</span>));</span><br><span class="line">        Long between = ChronoUnit.MINUTES.between(now, finalDate);</span><br><span class="line">        System.out.println(<span class="string">"minutes between now and ten days after: "</span> + between);</span><br></pre></td></tr></table></figure><h2 id="（2）interface的default函数"><a href="#（2）interface的default函数" class="headerlink" title="（2）interface的default函数"></a>（2）interface的default函数</h2><p>java8还是支持的接口可以设置default方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MathTool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-奇技淫巧"><a href="#5-奇技淫巧" class="headerlink" title="5. 奇技淫巧"></a>5. 奇技淫巧</h1><h2 id="（1）捕获多个Exception"><a href="#（1）捕获多个Exception" class="headerlink" title="（1）捕获多个Exception"></a>（1）捕获多个Exception</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/a/b.txt"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种每个都捕获的写法并不优雅，其实jdk7就提供了一种相对优雅的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/a/b.txt"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="(2) 字符串拼接"></a>(2) 字符串拼接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = String.join(<span class="string">","</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure><h1 id="6-引用"><a href="#6-引用" class="headerlink" title="6.引用"></a>6.引用</h1><ol><li><a href="https://stackoverflow.com/questions/16501/what-is-a-lambda-function" target="_blank" rel="noopener">https://stackoverflow.com/questions/16501/what-is-a-lambda-function</a></li><li><a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="noopener">http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/java8.jpg&quot; alt=&quot;java8&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javaStream" scheme="https://lccsetsun.github.io/categories/javaStream/"/>
    
    
      <category term="java8" scheme="https://lccsetsun.github.io/tags/java8/"/>
    
      <category term="Stream" scheme="https://lccsetsun.github.io/tags/Stream/"/>
    
      <category term="Filter" scheme="https://lccsetsun.github.io/tags/Filter/"/>
    
      <category term="Collectors" scheme="https://lccsetsun.github.io/tags/Collectors/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch 集群搭建</title>
    <link href="https://lccsetsun.github.io/2019/04/20/elk/"/>
    <id>https://lccsetsun.github.io/2019/04/20/elk/</id>
    <published>2019-04-20T08:47:28.000Z</published>
    <updated>2019-06-07T07:07:54.842Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/5.jpg" alt="java8"></p><a id="more"></a><h3 id="业务需求场景"><a href="#业务需求场景" class="headerlink" title="业务需求场景"></a>业务需求场景</h3><p>​    线上服务日志过多,为了方便监控系统运行状况,场景举例:</p><hr><h3 id="服务关系介绍"><a href="#服务关系介绍" class="headerlink" title="服务关系介绍"></a>服务关系介绍</h3><ul><li>A 服务网关 </li><li>B 具体服务 </li><li>C 拉取服务信息的集群(master work) </li><li>拉取信息(这里意为获取视频流 .h264)</li></ul><h3 id="运行逻辑概括"><a href="#运行逻辑概括" class="headerlink" title="运行逻辑概括"></a>运行逻辑概括</h3><ul><li><p>A服务网关</p></li><li><p>C服务调用网关,获取通行证</p></li><li><p>然后用C的work服务携带通行证去B 拉取信息存到消息队列,供下游算法执行相应的业务处理</p></li></ul><h3 id="目前存在问题"><a href="#目前存在问题" class="headerlink" title="目前存在问题"></a>目前存在问题</h3><ul><li>拉取信息超时错误代码(404,408…)</li><li>拉取信息失败(设置重试时间,一定时间后重试拉取)</li><li>获取网关通行证失败(c服务同一时间大量的去请求网关获取通行证,导致网关队列堵塞,处理不过来)</li><li>c服务增加任务失败,无响应</li></ul><hr><h3 id="拉取信息超时的原因总结"><a href="#拉取信息超时的原因总结" class="headerlink" title="拉取信息超时的原因总结"></a>拉取信息超时的原因总结</h3><p>1.获取网关通行证失败,或者获取不到,为此设置失败重试,直到拿到通行证为止</p><p>以上方案导致 网关会莫名其妙的挂掉,后面优化了网关的服务</p><p>2.拉取信息失败</p><p>原因当视频流不完整的时候体现为糊化,卡顿,由于我们拉取信息的代码逻辑是,不要糊化的视频,所以一旦出现卡顿糊化现象,也就是一秒二十四帧,丢了一帧,我们会全部抛弃之后的所有,知道抓到下一个I帧,也就是所谓的关键帧才会往消息队列里面存,这就导致了,提供服务信息的B平台看到有一点卡顿,而C平台则直接跳好几秒的情况,而一旦超过三秒没有收到数据包,则认为断流,系统将会主动断开连接,重新请求获取通行证,这样主动断开的操作是为了节约内存消耗,让没有拉取到信息的任务不在占用运行空间,给其他任务使用</p><p>3.获取网关通行证失败</p><p>​    这个可能原因是网关承受不住那么大的并发访问,导致一直阻塞内存飙升,网关不是我负责的,我也不清楚具体什么原因但是大致是因为并发太大承受不住的问题</p><p>4.c服务增加任务失败,无响应</p><p>这个问题主要是由第三个问题影响的蝴蝶效应,网关处理不过来,C新加的任务需要请求网关,然后一直在A的等待队列里面,没有任何回应,也没有错误代码,就卡在网关这里了,最后导致C服务也挂掉了</p><p>以上问题的排查步骤,都需要去机器上grep一下日志,查看当前点位是什么状态,如果请求成功,还要去work机器上,看看是因为拉取失败,还是真的没有信息,步骤繁琐,还要查询任务分配到集群的那个机器上,排查时间长,效率低,所以考虑不熟elk集群进行监控任务</p><p>Elk 部署前提,需要jdk支持</p><p>以下默认你已成功安装jdk</p><p>Elasticsearch 安装最新版  logstash 最新版 kibana 最新版 (20190407日官网下载最新稳定版本)</p><p>首先安装Elasticsearch</p><p>这里需要注意几点,Elasticsearch默认不支持root用户运行,需要新建普通用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">新建用户</span><br><span class="line">adduser elk</span><br><span class="line">设置密码</span><br><span class="line">passwd elk</span><br></pre></td></tr></table></figure><p>解压 Elasticsearch</p><p>进入 Elasticsearch/conf/Elasticsearch.yml</p><p>修改配置文件内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置服务名称</span></span><br><span class="line">cluster.name: elasticsearch_setsun<span class="comment">//# 集群的节点名称,默认也会创建一个,自己设置也是可以的</span></span><br><span class="line">node.name: <span class="string">"node-1"</span></span><br><span class="line"><span class="comment">// 这个参数控制的是，一个节点需要看到的具有master节点资格的最小数量，然后才能在集群中做操作。官方的推荐值是(N/2)+1，其中N是具有master资格的节点的数量,大致意思就是如果master挂掉了,则从这里查看还有几台具有master资格的机器,然后选取一台,如果低于两个,则集群可能就挂掉了,就变成单机了</span></span><br><span class="line">discovery.zen.minimum_master_nodes: <span class="number">2</span></span><br><span class="line"><span class="comment">// 这个属性表示节点是否存储数据</span></span><br><span class="line">node.data: <span class="keyword">true</span></span><br><span class="line"><span class="comment">// 是elasticsearch侦听的地方</span></span><br><span class="line">#network.bind_host: 0.0.0.0</span><br><span class="line"><span class="comment">// 集群通信端口</span></span><br><span class="line">transport.tcp.port: <span class="number">9300</span></span><br><span class="line"><span class="comment">// http监听端口</span></span><br><span class="line">http.port: <span class="number">9200</span></span><br><span class="line"><span class="comment">// 是否开启跨域访问</span></span><br><span class="line">http.cors.enabled: <span class="keyword">true</span></span><br><span class="line"><span class="comment">// 跨域请求匹配</span></span><br><span class="line">http.cors.allow-origin: <span class="string">"*"</span></span><br><span class="line"><span class="comment">//集群组件进行通信的地址//#network.publish_host: 127.0.0.//</span></span><br><span class="line"><span class="comment">// 这个参数是用来同时设置bind_host和publish_host上面两个参数。</span></span><br><span class="line">network.host: <span class="number">0.0</span>.0.0</span><br><span class="line"><span class="comment">// 设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点</span></span><br><span class="line">discovery.zen.ping.unicast.hosts: [<span class="string">"IP:9300"</span>,<span class="string">"IP:9300"</span>,<span class="string">"IP:9300"</span>,<span class="string">"IP:9300"</span>]</span><br><span class="line"></span><br><span class="line">bootstrap.memory_lock: <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">bootstrap.system_call_filter: <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">xpack.security.enabled: <span class="keyword">false</span></span><br><span class="line"><span class="comment">// 这个必须设置,不设置的话,外网放不到,应该是初始化master节点</span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">"node-1"</span>]</span><br></pre></td></tr></table></figure><p>剩下的直接拷贝写好的配置文件到其他机器上就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 批量拷贝配置文件至其他机器的Elasticsearch</span></span><br><span class="line">pscp   /home/Elasticsearch/Elasticsearch.yml -h host_list /home/Elasticsearch/Elasticsearch.yml</span><br><span class="line"><span class="comment">// 批量执行Elasticsearch服务</span></span><br><span class="line">pssh -h host_list -i <span class="string">"/home/Elasticsearch/bin/elasticsearch -d"</span></span><br></pre></td></tr></table></figure><p>然后到服务机器上安装logstash 解压之后配置文件如下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line"></span><br><span class="line">    file &#123;</span><br><span class="line"><span class="comment">// 日志文件的路径</span></span><br><span class="line">        path =&gt; <span class="string">"/log/VCS/Camera/Log/CameraManager_log_current.log*"</span></span><br><span class="line">        start_position =&gt; <span class="string">"beginning"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  grok &#123;</span><br><span class="line"><span class="comment">// 过滤正则表达式 </span></span><br><span class="line">match =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"(.+error.+)"</span>&#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//stdout &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//#    codec =&gt; rubydebug</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// #  &#125;</span></span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [<span class="string">"33.90.129.59:9200"</span>]</span><br><span class="line">    index =&gt; <span class="string">"lcc-%&#123;+YYYYMMdd&#125;"</span></span><br><span class="line">  manage_template =&gt; <span class="keyword">true</span></span><br><span class="line">    template_overwrite =&gt; <span class="keyword">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">步骤同上批量拷贝配置文件至其他服务机器上<span class="meta-keyword">/home/</span>logstash/conf</span><br><span class="line">pscp <span class="meta-keyword">/home/</span>logstash<span class="meta-keyword">/conf/</span>logstash.conf -h host_list <span class="meta-keyword">/home/</span>logstash<span class="meta-keyword">/conf/</span></span><br><span class="line">批量启动</span><br><span class="line">pssh -h host_list -i <span class="string">"/home/logstash/bin/logstash -f /home/logstash/conf/logstash.conf"</span></span><br></pre></td></tr></table></figure><p>Kibana 直接解压启动,默认配置就可以 , nohup /home/kibana/bin/kibana &amp;</p><p>访问IP:5601即可看到数据</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/5.jpg&quot; alt=&quot;java8&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="https://lccsetsun.github.io/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://lccsetsun.github.io/tags/elasticsearch/"/>
    
      <category term="elk" scheme="https://lccsetsun.github.io/tags/elk/"/>
    
      <category term="logstash" scheme="https://lccsetsun.github.io/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>docker 简单使用</title>
    <link href="https://lccsetsun.github.io/2019/04/11/dockerUse/"/>
    <id>https://lccsetsun.github.io/2019/04/11/dockerUse/</id>
    <published>2019-04-11T08:05:38.000Z</published>
    <updated>2019-06-07T06:59:28.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-使用"><a href="#Docker-使用" class="headerlink" title="Docker 使用"></a>Docker 使用</h2><p>docker 如何发布jar<br><a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:<span class="number">8</span>-jdk-alpineENV SPRING_OUTPUT_ANSI_ENABLED=ALWAYS \    </span><br><span class="line">JHIPSTER_SLEEP=<span class="number">0</span> \    </span><br><span class="line">JAVA_OPTS=<span class="string">""</span></span><br><span class="line"># add directly the war</span><br><span class="line">ADD *.jar /app.jar</span><br><span class="line">#设置运行景象 和北京时间</span><br><span class="line">RUN \    </span><br><span class="line">echo -e <span class="string">"https://mirrors.ustc.edu.cn/alpine/latest-stable/main\nhttps://mirrors.ustc.edu.cn/alpine/latest-stable/community"</span> &gt; /etc/apk/repositories &amp;&amp; \    </span><br><span class="line">apk update &amp;&amp; \    </span><br><span class="line">apk add --no-cache openssh tzdata &amp;&amp; \    </span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \    </span><br><span class="line">echo <span class="string">"xiaoshanyunwei"</span> &gt;  /etc/timezone &amp;&amp; \    </span><br><span class="line">rm -rf /<span class="keyword">var</span>/cache/apk<span class="comment">/*</span></span><br><span class="line"><span class="comment">EXPOSE 8094 5701/udp</span></span><br><span class="line"><span class="comment">CMD echo "The application will start in $&#123;JHIPSTER_SLEEP&#125;s..." &amp;&amp; \    </span></span><br><span class="line"><span class="comment">sleep $&#123;JHIPSTER_SLEEP&#125; &amp;&amp; \    </span></span><br><span class="line"><span class="comment">java $&#123;JAVA_OPTS&#125; -Djava.security.egd=file:/dev/./urandom -jar /app.jar</span></span><br></pre></td></tr></table></figure><ul><li>第二种写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dockerfile 设置服务景象 </span><br><span class="line">FROM openjdk</span><br><span class="line">MAINTAINER lcc</span><br><span class="line">ENV JAVA_HOME /use/local/java</span><br><span class="line">RUN echo $JAVA_HOME</span><br><span class="line">ADD client_lcc-V1.jar /root/lcc/docker/app.jar</span><br><span class="line">VOLUME [<span class="string">"/root/lcc/docker"</span>]</span><br><span class="line">WORKDIR /root/lcc/docker</span><br><span class="line">EXPOSE <span class="number">8888</span>/tcp</span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/root/lcc/docker/app.jar"</span>] </span><br><span class="line">CMD java $JAVA_HOME -Djava.security.egd=file:/dev/./urandom -jar /root/lcc/docker/app.jar</span><br></pre></td></tr></table></figure><ul><li><p>CMD    容器启动时运行的操作。该指令只能在文件中存在一次，如果有多个，则只执行最后一条</p></li><li><p>ENTRYPOINT 设置容器启动时执行的操作。该指令只能在文件中存在一次，如果有多个，则只执行最后一条</p></li><li>EXPOSE 指定容器需要映射到宿主机器的端口.  </li><li>VOLUME 指定挂载点(设置运行文件存放的路径)</li><li>WORKDIR 切换目录。可以多次切换工作目录(相当于cd命令)</li><li>ENV 指定容器运行环境</li><li>docker build -t lcc/test .    打包当前Dockerfile并指定名称</li><li>docker run -d（后台运行） -p（端口映射 主机端口：容器端口）–env-file=／dev.sh (读取环境变量) lcc</li><li>-m :设置容器使用内存最大值</li><li>rm ID    删除docker容器(先删除容器，在删除镜像)</li><li>rmi ID    删除docker镜像</li><li>docker logs -f lcc(容器name)|grep ‘关键词’</li><li>docker ps    展示运行容器列表</li><li>docker images    展示镜像列表</li><li>docker save -o nginx.tar(导出名称) nginx:latest(镜像名称). docker镜像导出</li><li>docker export -o nginx-test.tar nginx-test docker导入 支持自定义镜像名称</li><li>docker load -i nginx.tar docker导入 全部信息导入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q) 删除所有镜像</span><br><span class="line">docker rm $(docker ps -a -q) 删除所有容器|stop停止所有容器</span><br><span class="line">删除id为&lt;None&gt;的image</span><br><span class="line">docker rmi $(docker images | grep <span class="string">"^&lt;none&gt;"</span> | awk <span class="string">"&#123;print $3&#125;"</span>)</span><br><span class="line">删除指定容器</span><br><span class="line">docker rm $(docker ps -a|grep -w <span class="string">"name"</span>|awk <span class="string">"&#123;print $3&#125;"</span>)</span><br><span class="line">复制容器中的配置文件到宿主机目录</span><br><span class="line">docker cp [CONTAINER ID]:/usr/local/logs /etc/docker/openapi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker-使用&quot;&gt;&lt;a href=&quot;#Docker-使用&quot; class=&quot;headerlink&quot; title=&quot;Docker 使用&quot;&gt;&lt;/a&gt;Docker 使用&lt;/h2&gt;&lt;p&gt;docker 如何发布jar&lt;br&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://lccsetsun.github.io/tags/docker/"/>
    
      <category term="linux" scheme="https://lccsetsun.github.io/tags/linux/"/>
    
      <category term="shell" scheme="https://lccsetsun.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>validation自动校验参数</title>
    <link href="https://lccsetsun.github.io/2019/02/25/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84Validation%E6%B3%A8%E8%A7%A3/"/>
    <id>https://lccsetsun.github.io/2019/02/25/一些常用的Validation注解/</id>
    <published>2019-02-25T12:15:38.000Z</published>
    <updated>2019-06-07T07:02:05.431Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/4.jpg" alt="hashmap"></p><a id="more"></a><h2 id="记录一次springboot整合validation参数校验踩过的坑"><a href="#记录一次springboot整合validation参数校验踩过的坑" class="headerlink" title="记录一次springboot整合validation参数校验踩过的坑"></a>记录一次springboot整合validation参数校验踩过的坑</h2><ul><li>pom文件引入相关的基本依赖</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--核心依赖--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>根据网上的提示引入validation依赖</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.4.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>注意这里引入这个依赖之后各种坑，postman传参接收不到，一开始不论传什么，设置条件都会全部出来。。。</li><li>后来debug之后才发现是传的参数根本没进来，经过一番源码debug，并没有发现什么不对劲的地方，就是到了判断参数的时候，参数为空.</li></ul><h3 id="更换-validation依赖-如下"><a href="#更换-validation依赖-如下" class="headerlink" title="更换 validation依赖 如下"></a>更换 validation依赖 如下</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>既然整合那就整合优雅一点，让代码看上去不那么繁琐，如果整合之后的代码量更多，更复杂，那就失去整合的意义了，不如if()else{} 一个一个判断，所以就有下面全局异常处理</li></ul><h3 id="设置全局异常返回类"><a href="#设置全局异常返回类" class="headerlink" title="设置全局异常返回类"></a>设置全局异常返回类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConversionException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.FieldError;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.ObjectError;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadRequestExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(BadRequestExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  校验错误拦截处理</span></span><br><span class="line"><span class="comment">     *ExceptionHandler 注解必须要表明自己想要处理的异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)。是为了想返回指定的错误代码</span></span><br><span class="line"><span class="comment">     *  比如：200 400 500</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception 错误信息集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException.class)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">validationBodyException</span><span class="params">(MethodArgumentNotValidException exception)</span></span>&#123;</span><br><span class="line">        BindingResult result = exception.getBindingResult();</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            List&lt;ObjectError&gt; errors = result.getAllErrors();</span><br><span class="line">            errors.forEach(p -&gt;&#123;</span><br><span class="line">                FieldError fieldError = (FieldError) p;</span><br><span class="line">                logger.error(<span class="string">"Data check failure : object&#123;"</span>+fieldError.getObjectName()+<span class="string">"&#125;,field&#123;"</span>+fieldError.getField()+</span><br><span class="line">                    <span class="string">"&#125;,errorMessage&#123;"</span>+fieldError.getDefaultMessage()+<span class="string">"&#125;"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(<span class="string">"请填写正确信息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数类型转换错误</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception 错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(HttpMessageConversionException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resp <span class="title">parameterTypeException</span><span class="params">(HttpMessageConversionException exception)</span></span>&#123;</span><br><span class="line">        logger.error(exception.getCause().getLocalizedMessage());</span><br><span class="line">        <span class="keyword">return</span> Resp.fail(<span class="string">"类型转换错误"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Controller 层 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/v1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestValidation</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TestValidation.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/validation"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resp <span class="title">validation</span><span class="params">(@Valid @RequestBody PersionTest persionTest)</span></span>&#123;</span><br><span class="line">        logger.info(persionTest.toString);</span><br><span class="line">        <span class="keyword">return</span> Resp.success(<span class="string">"lcc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>PO写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Max;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Min;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Length;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.NotEmpty;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.validator.constraints.Range;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersionTest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Length</span>(min=<span class="number">3</span>, max=<span class="number">20</span>, message=<span class="string">"name长度只能在6-20之间"</span>)</span><br><span class="line">    <span class="meta">@NotEmpty</span>(message=<span class="string">"用户名不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range</span>(min = <span class="number">18</span>,max = <span class="number">100</span>,message = <span class="string">"必须在18-100之间"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">1</span>, message = <span class="string">"min Value is above zero"</span>)</span><br><span class="line">    <span class="meta">@Max</span>(value = <span class="number">10</span>, message = <span class="string">"最大值不超过10"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer Clas_p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*以下列举部分常用的validation相关的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注解作用</span><br><span class="line"><span class="meta">@NotNull</span>值不能为空</span><br><span class="line"><span class="meta">@Null</span>值必须为空</span><br><span class="line"><span class="meta">@Pattern</span>(regex=)字符串必须匹配正则表达式</span><br><span class="line"><span class="meta">@Size</span>(min, max)集合元素的数量必须在min和max之间</span><br><span class="line"><span class="meta">@CreditCardNumber</span>(ignoreNonDigitCharacters=)字符串必须是信用卡号，按找美国的标准验证</span><br><span class="line"><span class="meta">@Email</span>字符串必须是Email地址</span><br><span class="line"><span class="meta">@Length</span>(min, max)检查字符串的长度</span><br><span class="line"><span class="meta">@NotBlank</span>字符串不能为空串</span><br><span class="line"><span class="meta">@NotEmpty</span>字符串不能为<span class="keyword">null</span>, 集合必须有元素</span><br><span class="line"><span class="meta">@Range</span>(min, max)数字必须大于min, 小于max</span><br><span class="line"><span class="meta">@SafeHtml</span>字符串必须是安全的html</span><br><span class="line"><span class="meta">@URL</span>字符串必须是合法的URL</span><br><span class="line"><span class="meta">@AssertFalse</span>值必须是<span class="keyword">false</span></span><br><span class="line"><span class="meta">@AssertTrue</span>值必须是<span class="keyword">true</span></span><br><span class="line"><span class="meta">@DecimalMax</span>(value=, inclusive=)值必须小于等于(inclusive=<span class="keyword">true</span>)/小于(inclusive=<span class="keyword">false</span>)属性指定的值，也可以注释在字符串类型的属性上。</span><br><span class="line"><span class="meta">@DecimalMin</span>(value=, inclusive=)值必须大于等于(inclusive=<span class="keyword">true</span>)/小于(inclusive=<span class="keyword">false</span>)属性指定的值，也可以注释在字符串类型的属性上。</span><br><span class="line"><span class="meta">@Digist</span>(integer=,fraction=)数字格式检查。integer指定整数部分的最大长度，fraction指定小数部分的最大长度</span><br><span class="line"><span class="meta">@Future</span>时间必须是未来的</span><br><span class="line"><span class="meta">@Past</span>事件必须是过去的</span><br><span class="line"><span class="meta">@Max</span>(value=)值必须小于等于value指定的值。不能注解在字符串类型属性上。</span><br><span class="line"><span class="meta">@Min</span>(value=)值必须小于等于value指定的值。不能注解在字符串类型属性上。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/4.jpg&quot; alt=&quot;hashmap&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="validation" scheme="https://lccsetsun.github.io/tags/validation/"/>
    
      <category term="boot" scheme="https://lccsetsun.github.io/tags/boot/"/>
    
  </entry>
  
</feed>
